# Castle DynamicProxy Interceptor - Simple Explanation

## What is an Interceptor?

An **interceptor** is like a "middleman" that sits between your code and the actual method being called. 
Think of it like a security checkpoint at an airport - every passenger (method call) must go through 
the checkpoint (interceptor) before reaching the gate (actual method).

## The Problem We're Solving

Imagine you have a Calculator class and you want to:
- Log every time someone uses it
- Measure how long each operation takes
- Handle errors gracefully

WITHOUT interceptors, you'd have to add logging and timing code inside EVERY method:

```csharp
public int Add(int a, int b)
{
    Console.WriteLine("Add called");           // Logging
    var stopwatch = Stopwatch.StartNew();      // Performance tracking
    
    int result = a + b;                        // Actual business logic
    
    stopwatch.Stop();                          // Performance tracking
    Console.WriteLine($"Took {stopwatch.ElapsedMilliseconds}ms");
    return result;
}
```

This is messy because:
- Business logic is mixed with logging/monitoring
- You have to repeat this code in EVERY method
- Hard to maintain and change

## The Interceptor Solution

With interceptors, you separate concerns:

### 1. Business Logic (Calculator.cs)
```csharp
public int Add(int a, int b)
{
    return a + b;  // Clean! Just business logic
}
```

### 2. Logging (LoggingInterceptor.cs)
```csharp
public class LoggingInterceptor : IInterceptor
{
    public void Intercept(IInvocation invocation)
    {
        // BEFORE the method runs
        Console.WriteLine($"Calling: {invocation.Method.Name}");
        
        // Run the actual method
        invocation.Proceed();
        
        // AFTER the method runs
        Console.WriteLine($"Result: {invocation.ReturnValue}");
    }
}
```

### 3. Performance Tracking (PerformanceInterceptor.cs)
```csharp
public class PerformanceInterceptor : IInterceptor
{
    public void Intercept(IInvocation invocation)
    {
        var stopwatch = Stopwatch.StartNew();
        
        invocation.Proceed();  // Run the method
        
        stopwatch.Stop();
        Console.WriteLine($"Took: {stopwatch.ElapsedMilliseconds}ms");
    }
}
```

## How It Works - Step by Step

### Step 1: Define an Interface
```csharp
public interface ICalculator
{
    int Add(int a, int b);
}
```
**Why?** Castle DynamicProxy requires an interface to create proxies.

### Step 2: Create Implementation
```csharp
public class Calculator : ICalculator
{
    public int Add(int a, int b) => a + b;
}
```

### Step 3: Wrap with Proxy
```csharp
var proxyGenerator = new ProxyGenerator();
var calculator = proxyGenerator.CreateInterfaceProxyWithTarget<ICalculator>(
    new Calculator(),              // The real object
    new LoggingInterceptor(),      // First interceptor
    new PerformanceInterceptor()   // Second interceptor
);
```

### Step 4: Use It Normally
```csharp
int result = calculator.Add(5, 3);
```

## What Happens When You Call calculator.Add(5, 3)?

Here's the journey:

```
1. You call: calculator.Add(5, 3)
   ↓
2. LoggingInterceptor runs:
   - Logs: "Calling method: Add(5, 3)"
   - Calls: invocation.Proceed()
   ↓
3. PerformanceInterceptor runs:
   - Starts timer
   - Calls: invocation.Proceed()
   ↓
4. ACTUAL Calculator.Add(5, 3) runs:
   - Returns: 8
   ↓
5. PerformanceInterceptor continues:
   - Stops timer
   - Logs: "Method Add executed in 0ms"
   ↓
6. LoggingInterceptor continues:
   - Logs: "Method Add returned: 8"
   ↓
7. Result (8) is returned to you
```

**Console Output:**
```
[LOG] Calling method: Add(5, 3)
[LOG] Method Add returned: 8
[PERF] Method Add executed in 0ms
```

## Key Concepts

### The IInvocation Object
This object contains everything about the method call:

```csharp
public void Intercept(IInvocation invocation)
{
    invocation.Method.Name      // "Add"
    invocation.Arguments        // [5, 3]
    invocation.Proceed()        // Calls next interceptor or actual method
    invocation.ReturnValue      // 8 (available after Proceed)
}
```

### Multiple Interceptors = Chain of Responsibility

When you have multiple interceptors:
```csharp
new LoggingInterceptor(),      // Runs first
new PerformanceInterceptor()   // Runs second
```

They form a chain:
```
Your Code → Logging → Performance → Real Method → Performance → Logging → Your Code
           (before)  (before)        (runs)       (after)      (after)
```

### invocation.Proceed() is Critical!

- **MUST call** `invocation.Proceed()` to continue the chain
- If you DON'T call it, the actual method never runs!
- You can call it in try-catch to handle errors
- Everything before `Proceed()` = "before method runs"
- Everything after `Proceed()` = "after method runs"

## Real-World Use Cases

### 1. **Logging** (What we did)
Automatically log all method calls without touching business logic

### 2. **Caching**
```csharp
public class CachingInterceptor : IInterceptor
{
    private Dictionary<string, object> _cache = new();
    
    public void Intercept(IInvocation invocation)
    {
        string key = $"{invocation.Method.Name}_{string.Join("_", invocation.Arguments)}";
        
        if (_cache.ContainsKey(key))
        {
            invocation.ReturnValue = _cache[key];  // Return cached result
            return;  // Don't call Proceed()!
        }
        
        invocation.Proceed();  // Call actual method
        _cache[key] = invocation.ReturnValue;  // Cache the result
    }
}
```

### 3. **Authorization**
```csharp
public class AuthorizationInterceptor : IInterceptor
{
    public void Intercept(IInvocation invocation)
    {
        if (!User.IsAuthenticated())
        {
            throw new UnauthorizedException();
        }
        
        invocation.Proceed();  // Only proceed if authorized
    }
}
```

### 4. **Retry Logic**
```csharp
public class RetryInterceptor : IInterceptor
{
    public void Intercept(IInvocation invocation)
    {
        int attempts = 0;
        while (attempts < 3)
        {
            try
            {
                invocation.Proceed();
                return;  // Success!
            }
            catch (Exception)
            {
                attempts++;
                if (attempts >= 3) throw;
                Thread.Sleep(1000);  // Wait before retry
            }
        }
    }
}
```

## Benefits of This Approach

✅ **Separation of Concerns**: Business logic stays clean
✅ **Reusability**: Write interceptor once, use on any class
✅ **Maintainability**: Change logging in one place, affects all methods
✅ **Testability**: Test business logic without logging/monitoring
✅ **Flexibility**: Add/remove interceptors without changing code

## How It's Used in This Project

### Program.cs
```csharp
// Create the proxied calculator
var calculator = proxyGenerator.CreateInterfaceProxyWithTarget<ICalculator>(
    new Calculator(),              // Real implementation
    new LoggingInterceptor(),      // Logs all calls
    new PerformanceInterceptor()   // Measures speed
);

// Register in DI container
builder.Services.AddSingleton<ICalculator>(calculator);
```

### CalculatorController.cs
```csharp
public class CalculatorController : ControllerBase
{
    private readonly ICalculator _calculator;
    
    public CalculatorController(ICalculator calculator)
    {
        _calculator = calculator;  // Gets the PROXIED calculator
    }
    
    [HttpGet("add/{a}/{b}")]
    public IActionResult Add(int a, int b)
    {
        var result = _calculator.Add(a, b);  // Interceptors run automatically!
        return Ok(new { result });
    }
}
```

When you call `GET /api/calculator/add/5/3`:
1. Request hits CalculatorController
2. Controller calls `_calculator.Add(5, 3)`
3. LoggingInterceptor logs the call
4. PerformanceInterceptor starts timer
5. Actual Calculator.Add(5, 3) executes
6. PerformanceInterceptor logs execution time
7. LoggingInterceptor logs the result
8. Result is returned to the client

## Common Mistakes to Avoid

❌ **Forgetting to call Proceed()**
```csharp
public void Intercept(IInvocation invocation)
{
    Console.WriteLine("Before");
    // Forgot invocation.Proceed()!
    Console.WriteLine("After");
}
// The actual method never runs!
```

❌ **Accessing ReturnValue before Proceed()**
```csharp
public void Intercept(IInvocation invocation)
{
    Console.WriteLine(invocation.ReturnValue);  // NULL or default!
    invocation.Proceed();
}
```

❌ **Not handling exceptions**
```csharp
public void Intercept(IInvocation invocation)
{
    invocation.Proceed();
    // If Proceed() throws, your code after won't run
}

// Better:
public void Intercept(IInvocation invocation)
{
    try
    {
        invocation.Proceed();
    }
    finally
    {
        // This ALWAYS runs
    }
}
```

## Summary

**Interceptors = Middleware for your methods**

Instead of writing logging/monitoring/caching code in every method, you:
1. Keep your business logic clean
2. Write interceptors once
3. Wrap your objects with proxies
4. Let Castle DynamicProxy handle the magic

It's like having a personal assistant that handles all the boring stuff (logging, timing, etc.) 
while you focus on the actual work!
